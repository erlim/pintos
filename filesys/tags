!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
FILESYS_DIRECTORY_H	directory.h	2;"	d
FILESYS_FILESYS_H	filesys.h	2;"	d
FILESYS_FILE_H	file.h	2;"	d
FILESYS_FREE_MAP_H	free-map.h	2;"	d
FILESYS_FSUTIL_H	fsutil.h	2;"	d
FILESYS_INODE_H	inode.h	2;"	d
FILESYS_OFF_T_H	off_t.h	2;"	d
FREE_MAP_SECTOR	filesys.h	8;"	d
INODE_MAGIC	inode.c	11;"	d	file:
NAME_MAX	directory.h	12;"	d
PROTd	off_t.h	13;"	d
ROOT_DIR_SECTOR	filesys.h	9;"	d
byte_to_sector	inode.c	/^byte_to_sector (const struct inode *inode, off_t pos) $/;"	f	file:
bytes_to_sectors	inode.c	/^bytes_to_sectors (off_t size)$/;"	f	file:
data	inode.c	/^    struct inode_disk data;             \/* Inode content. *\/$/;"	m	struct:inode	typeref:struct:inode::inode_disk	file:
deny_write	file.c	/^    bool deny_write;            \/* Has file_deny_write() been called? *\/$/;"	m	struct:file	file:
deny_write_cnt	inode.c	/^    int deny_write_cnt;                 \/* 0: writes ok, >0: deny writes. *\/$/;"	m	struct:inode	file:
dir	directory.c	/^struct dir $/;"	s	file:
dir_add	directory.c	/^dir_add (struct dir *dir, const char *name, block_sector_t inode_sector)$/;"	f
dir_close	directory.c	/^dir_close (struct dir *dir) $/;"	f
dir_create	directory.c	/^dir_create (block_sector_t sector, size_t entry_cnt)$/;"	f
dir_entry	directory.c	/^struct dir_entry $/;"	s	file:
dir_get_inode	directory.c	/^dir_get_inode (struct dir *dir) $/;"	f
dir_lookup	directory.c	/^dir_lookup (const struct dir *dir, const char *name,$/;"	f
dir_open	directory.c	/^dir_open (struct inode *inode) $/;"	f
dir_open_root	directory.c	/^dir_open_root (void)$/;"	f
dir_readdir	directory.c	/^dir_readdir (struct dir *dir, char name[NAME_MAX + 1])$/;"	f
dir_remove	directory.c	/^dir_remove (struct dir *dir, const char *name) $/;"	f
dir_reopen	directory.c	/^dir_reopen (struct dir *dir) $/;"	f
do_format	filesys.c	/^do_format (void)$/;"	f	file:
elem	inode.c	/^    struct list_elem elem;              \/* Element in inode list. *\/$/;"	m	struct:inode	typeref:struct:inode::list_elem	file:
file	file.c	/^struct file $/;"	s	file:
file_allow_write	file.c	/^file_allow_write (struct file *file) $/;"	f
file_close	file.c	/^file_close (struct file *file) $/;"	f
file_deny_write	file.c	/^file_deny_write (struct file *file) $/;"	f
file_get_inode	file.c	/^file_get_inode (struct file *file) $/;"	f
file_length	file.c	/^file_length (struct file *file) $/;"	f
file_open	file.c	/^file_open (struct inode *inode) $/;"	f
file_read	file.c	/^file_read (struct file *file, void *buffer, off_t size) $/;"	f
file_read_at	file.c	/^file_read_at (struct file *file, void *buffer, off_t size, off_t file_ofs) $/;"	f
file_reopen	file.c	/^file_reopen (struct file *file) $/;"	f
file_seek	file.c	/^file_seek (struct file *file, off_t new_pos)$/;"	f
file_tell	file.c	/^file_tell (struct file *file) $/;"	f
file_write	file.c	/^file_write (struct file *file, const void *buffer, off_t size) $/;"	f
file_write_at	file.c	/^file_write_at (struct file *file, const void *buffer, off_t size,$/;"	f
filesys_create	filesys.c	/^filesys_create (const char *name, off_t initial_size) $/;"	f
filesys_done	filesys.c	/^filesys_done (void) $/;"	f
filesys_init	filesys.c	/^filesys_init (bool format) $/;"	f
filesys_open	filesys.c	/^filesys_open (const char *name)$/;"	f
filesys_remove	filesys.c	/^filesys_remove (const char *name) $/;"	f
free_map	free-map.c	/^static struct bitmap *free_map;      \/* Free map, one bit per sector. *\/$/;"	v	typeref:struct:bitmap	file:
free_map_allocate	free-map.c	/^free_map_allocate (size_t cnt, block_sector_t *sectorp)$/;"	f
free_map_close	free-map.c	/^free_map_close (void) $/;"	f
free_map_create	free-map.c	/^free_map_create (void) $/;"	f
free_map_file	free-map.c	/^static struct file *free_map_file;   \/* Free map file. *\/$/;"	v	typeref:struct:file	file:
free_map_init	free-map.c	/^free_map_init (void) $/;"	f
free_map_open	free-map.c	/^free_map_open (void) $/;"	f
free_map_release	free-map.c	/^free_map_release (block_sector_t sector, size_t cnt)$/;"	f
fs_device	filesys.c	/^struct block *fs_device;$/;"	v	typeref:struct:block
fs_device	filesys.h	/^struct block *fs_device;$/;"	v	typeref:struct:block
fsutil_append	fsutil.c	/^fsutil_append (char **argv)$/;"	f
fsutil_cat	fsutil.c	/^fsutil_cat (char **argv)$/;"	f
fsutil_extract	fsutil.c	/^fsutil_extract (char **argv UNUSED) $/;"	f
fsutil_ls	fsutil.c	/^fsutil_ls (char **argv UNUSED) $/;"	f
fsutil_rm	fsutil.c	/^fsutil_rm (char **argv) $/;"	f
in_use	directory.c	/^    bool in_use;                        \/* In use or free? *\/$/;"	m	struct:dir_entry	file:
inode	directory.c	/^    struct inode *inode;                \/* Backing store. *\/$/;"	m	struct:dir	typeref:struct:dir::inode	file:
inode	file.c	/^    struct inode *inode;        \/* File's inode. *\/$/;"	m	struct:file	typeref:struct:file::inode	file:
inode	inode.c	/^struct inode $/;"	s	file:
inode_allow_write	inode.c	/^inode_allow_write (struct inode *inode) $/;"	f
inode_close	inode.c	/^inode_close (struct inode *inode) $/;"	f
inode_create	inode.c	/^inode_create (block_sector_t sector, off_t length)$/;"	f
inode_deny_write	inode.c	/^inode_deny_write (struct inode *inode) $/;"	f
inode_disk	inode.c	/^struct inode_disk$/;"	s	file:
inode_get_inumber	inode.c	/^inode_get_inumber (const struct inode *inode)$/;"	f
inode_init	inode.c	/^inode_init (void) $/;"	f
inode_length	inode.c	/^inode_length (const struct inode *inode)$/;"	f
inode_open	inode.c	/^inode_open (block_sector_t sector)$/;"	f
inode_read_at	inode.c	/^inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset) $/;"	f
inode_remove	inode.c	/^inode_remove (struct inode *inode) $/;"	f
inode_reopen	inode.c	/^inode_reopen (struct inode *inode)$/;"	f
inode_sector	directory.c	/^    block_sector_t inode_sector;        \/* Sector number of header. *\/$/;"	m	struct:dir_entry	file:
inode_write_at	inode.c	/^inode_write_at (struct inode *inode, const void *buffer_, off_t size,$/;"	f
length	inode.c	/^    off_t length;                       \/* File size in bytes. *\/$/;"	m	struct:inode_disk	file:
lookup	directory.c	/^lookup (const struct dir *dir, const char *name,$/;"	f	file:
magic	inode.c	/^    unsigned magic;                     \/* Magic number. *\/$/;"	m	struct:inode_disk	file:
name	directory.c	/^    char name[NAME_MAX + 1];            \/* Null terminated file name. *\/$/;"	m	struct:dir_entry	file:
off_t	off_t.h	/^typedef int32_t off_t;$/;"	t
open_cnt	inode.c	/^    int open_cnt;                       \/* Number of openers. *\/$/;"	m	struct:inode	file:
open_inodes	inode.c	/^static struct list open_inodes;$/;"	v	typeref:struct:list	file:
pos	directory.c	/^    off_t pos;                          \/* Current position. *\/$/;"	m	struct:dir	file:
pos	file.c	/^    off_t pos;                  \/* Current position. *\/$/;"	m	struct:file	file:
removed	inode.c	/^    bool removed;                       \/* True if deleted, false otherwise. *\/$/;"	m	struct:inode	file:
sector	inode.c	/^    block_sector_t sector;              \/* Sector number of disk location. *\/$/;"	m	struct:inode	file:
start	inode.c	/^    block_sector_t start;               \/* First data sector. *\/$/;"	m	struct:inode_disk	file:
unused	inode.c	/^    uint32_t unused[125];               \/* Not used. *\/$/;"	m	struct:inode_disk	file:
